<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<title>webmonome - gol</title>
		<style>
			body {
				height: 100vh;
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				background: #0f0f0f;
			}
			canvas {
				max-width: 90%;
				max-height: 90%;
				aspect-ratio: 2;
			}
			button {
				position: absolute;
				bottom: 16px;
				right: 16px;
				margin: 8px 0 0 0;
				padding: 4px 8px;
				border: 2px solid rgba(255, 255, 255, .9);
				border-radius: 4px;
				outline: none;
				background: rgba(255, 255, 255, .9);
				color: #0f0f0f;
			}
		</style>
	</head>

	<body>
		<button>connect</button>
		<script type="module">
			import Monome from '../src/Monome.js';

			const monome = new Monome();
			window.monome = monome;
			const grid = monome.createCanvasGrid({
				activeColor: '#efefef',
				inactiveColor: '#0f0f0f',
				borderColor: '#efefef',
			});

			const btn = document.querySelector('button');
			btn.addEventListener('click', async () => {
				await monome.connect();
				monome.getGridSize();
			});

			const keydown = e => {
				monome.gridLed(e.x, e.y, true);
			};

			const keyup = e => {
				monome.gridLed(e.x, e.y);
			};

			const logEvent = e => {
				console.log(e);
			};

			const draw = (state, width, height) => {
				const drawquad = (s, x, y) => {
					const quad = s
						.slice(y, y + 8)
						.map(row => row.slice(x, x + 8))
						.flat();
					monome.gridLedMap(x, y, quad);
				};

				let heightOffset = 0;
				while (heightOffset < height) {
					let widthOffset = 0;
					while (widthOffset < width) {
						drawquad(state, widthOffset, heightOffset);
						widthOffset += 8;
					}
					heightOffset += 8;
				}
			};

			const nextGeneration = state => {
				const next = new Array(state.length);
				for (let i = 0; i < state.length; i++) {
					next[i] = new Array(state[i].length);
					for (let j = 0; j < state[i].length; j++) {
						const val = state[i][j];
						const neighbors = countNeighbors(state, i, j);

						if (!val && neighbors === 3) {
							next[i][j] = 1;
						} else if (val === 1 && (neighbors < 2 || neighbors > 3)) {
							next[i][j] = 0;
						} else {
							next[i][j] = val;
						}
					}
				}
				return next;
			};

			const countNeighbors = (state, y, x) => {
				let sum = 0;
				const height = state.length;
				const width = state[0].length;

				for (let i = -1; i < 2; i++) {
					for (let j = -1; j < 2; j++) {
						const row = (y + i + height) % height;
						const col = (x + j + width) % width;
						sum += state[row][col];
					}
				}
				sum -= state[y][x];
				return sum;
			};

			let started = false;
			let height = 8;
			let width = 16;
			const start = () => {
				if (started) return;
				started = true;
				const activekeys = {};

				let state = new Array(height);
				for (let i = 0; i < height; i++) {
					state[i] = new Array(width);
					for (let j = 0; j < width; j++) {
						state[i][j] = Math.floor(Math.random() * 2);
					}
				}

				const lifecycle = () => {
					state = nextGeneration(state);
					Object.values(activekeys).forEach(({ x, y }) => {
						state[y][x] = 1;
					});
					draw(state, width, height);

					setTimeout(lifecycle, 100);
				};

				lifecycle();

				let keysPressed = 0;
				const keydown = e => {
					keysPressed += 1;
					activekeys[`x${e.x}y${e.y}`] = {
						x: e.x,
						y: e.y,
					};
					monome.gridLed(e.x, e.y, true);
				};

				const keyup = e => {
					keysPressed = Math.max(keysPressed - 1, 0);
					delete activekeys[`x${e.x}y${e.y}`];
				};

				monome.on('gridKeyDown', keydown);
				monome.on('gridKeyUp', keyup);
			};

			monome.on('getGridSize', ({x, y}) => {
				width = Math.max(x, 8);
				height = Math.max(y, 8);
				if (grid?.canvas) {
					grid.canvas.style.aspectRatio = `${width} / ${height}`;
				}
			});

			document.body.prepend(grid.canvas);
			document.addEventListener('DOMContentLoaded', start);
		</script>
	</body>
</html>
